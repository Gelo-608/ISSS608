[
  {
    "objectID": "Hands-on Exercises/Hands-on Ex 05/Hands-on Ex 5-4.html",
    "href": "Hands-on Exercises/Hands-on Ex 05/Hands-on Ex 5-4.html",
    "title": "Hands-on Ex 5-4",
    "section": "",
    "text": "In this hands-on exercise, you will gain hands-on experiences on designing treemap using appropriate R packages. The hands-on exercise consists of three main section. First, you will learn how to manipulate transaction data into a treemap strcuture by using selected functions provided inÂ dplyrpackage. Then, you will learn how to plot static treemap by usingÂ treemappackage. In the third section, you will learn how to design interactive treemap by usingÂ d3treeRÂ package.\n\n\n\nBefore we get started, you are required to check ifÂ treemapÂ andÂ tidyversepacakges have been installed in you R.\n\npacman::p_load(treemap, treemapify, tidyverse) \n\n\n\n\nIn this exercise,Â REALIS2018.csvÂ data will be used. This dataset provides information of private property transaction records in 2018. The dataset is extracted from REALIS portal (https://spring.ura.gov.sg/lad/ore/login/index.cfm) of Urban Redevelopment Authority (URA).\n\n\nIn the code chunk below,Â read_csv()Â ofÂ readrÂ is used to import realis2018.csv into R and parsed it into tibble R data.frame format.\n\nrealis2018 &lt;- read_csv(\"/Users/geloliu/Gelo-608/ISSS608/Hands-on Exercises/Hands-on Ex 05/data/realis2018.csv\")\n\nRows: 23205 Columns: 20\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \",\"\nchr (12): Project Name, Address, Type of Area, Nett Price($), Sale Date, Pro...\ndbl  (8): No. of Units, Area (sqm), Transacted Price ($), Unit Price ($ psm)...\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nThe output tibble data.frame is calledÂ realis2018.\n\n\n\nThe data.frameÂ realis2018Â is in trasaction record form, which is highly disaggregated and not appropriate to be used to plot a treemap. In this section, we will perform the following steps to manipulate and prepare a data.frtame that is appropriate for treemap visualisation:\n\ngroup transaction records byÂ Project Name,Â Planning Region,Â Planning Area,Â Property TypeÂ andÂ Type of Sale, and\ncomputeÂ Total Unit Sold,Â Total Area,Â Median Unit PriceÂ andÂ Median Transacted PriceÂ by applying appropriate summary statistics onÂ No.Â of Units,Â Area (sqm),Â Unit Price ($ psm)Â andÂ Transacted Price ($)respectively.\n\nTwo key verbs ofÂ dplyrÂ package, namely:Â group_by()Â andÂ summarize()Â will be used to perform these steps.\ngroup_by()Â breaks down a data.frame into specified groups of rows. When you then apply the verbs above on the resulting object theyâ€™ll be automatically applied â€œby groupâ€.\nGrouping affects the verbs as follows:\n\ngroupedÂ select()Â is the same as ungroupedÂ select(), except that grouping variables are always retained.\ngroupedÂ arrange()Â is the same as ungrouped; unless you setÂ .by_group = TRUE, in which case it orders first by the grouping variables.\nmutate()Â andÂ filter()Â are most useful in conjunction with window functions (likeÂ rank(), orÂ min(x) == x). They are described in detail in vignette(â€œwindow-functionsâ€).\nsample_n()Â andÂ sample_frac()Â sample the specified number/fraction of rows in each group.\nsummarise()Â computes the summary for each group.\n\nIn our case,Â group_by()Â will used together withÂ summarise()Â to derive the summarised data.frame.\nğŸ“£ Students who are new toÂ dplyrÂ methods should consultÂ Introduction to dplyrbefore moving on to the next section.\n\n\n\nThe code chank below shows a typical two lines code approach to perform the steps.\n\nrealis2018_grouped &lt;- group_by(realis2018, `Project Name`,\n                               `Planning Region`, `Planning Area`, \n                               `Property Type`, `Type of Sale`)\nrealis2018_summarised &lt;- summarise(realis2018_grouped, \n                          `Total Unit Sold` = sum(`No. of Units`, na.rm = TRUE),\n                          `Total Area` = sum(`Area (sqm)`, na.rm = TRUE),\n                          `Median Unit Price ($ psm)` = median(`Unit Price ($ psm)`, na.rm = TRUE), \n                          `Median Transacted Price` = median(`Transacted Price ($)`, na.rm = TRUE))\n\n`summarise()` has grouped output by 'Project Name', 'Planning Region',\n'Planning Area', 'Property Type'. You can override using the `.groups`\nargument.\n\n\nğŸ“’ Note\n\nAggregation functions such asÂ sum()Â andÂ meadian()Â obey the usual rule of missing values: if thereâ€™s any missing value in the input, the output will be a missing value. The argumentÂ na.rm = TRUEÂ removes the missing values prior to computation.\n\nThe code chunk above is not very efficient because we have to give each intermediate data.frame a name, even though we donâ€™t have to care about it.\n\n\n\nThe code chunk below shows a more efficient way to tackle the same processes by using theÂ pipe, %&gt;%:\nğŸ”” Recommendation\nTo learn more about pipe, visit this excellent article:Â Pipes in R Tutorial For Beginners.\n\nrealis2018_summarised &lt;- realis2018 %&gt;% \n  group_by(`Project Name`,`Planning Region`, \n           `Planning Area`, `Property Type`, \n           `Type of Sale`) %&gt;%\n  summarise(`Total Unit Sold` = sum(`No. of Units`, na.rm = TRUE), \n            `Total Area` = sum(`Area (sqm)`, na.rm = TRUE),\n            `Median Unit Price ($ psm)` = median(`Unit Price ($ psm)`, na.rm = TRUE),\n            `Median Transacted Price` = median(`Transacted Price ($)`, na.rm = TRUE))\n\n`summarise()` has grouped output by 'Project Name', 'Planning Region',\n'Planning Area', 'Property Type'. You can override using the `.groups`\nargument.\n\n\n\n\n\n\ntreemapÂ package is a R package specially designed to offer great flexibility in drawing treemaps. The core function, namely:Â treemap()Â offers at least 43 arguments. In this section, we will only explore the major arguments for designing elegent and yet truthful treemaps.\n\n\nIn this section,Â treemap()Â ofÂ TreemapÂ package is used to plot a treemap showing the distribution of median unit prices and total unit sold of resale condominium by geographic hierarchy in 2017.\nFirst, we will select records belongs to resale condominium property type fromÂ realis2018_selectedÂ data frame.\n\nrealis2018_selected &lt;- realis2018_summarised %&gt;%\n  filter(`Property Type` == \"Condominium\", `Type of Sale` == \"Resale\")\n\n\n\n\nThe code chunk below designed a treemap by using three core arguments ofÂ treemap(), namely:Â index,Â vSizeÂ andÂ vColor.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\nThings to learn from the three arguments used:\n\nindex\n\nThe index vector must consist of at least two column names or else no hierarchy treemap will be plotted.\nIf multiple column names are provided, such as the code chunk above, the first name is the highest aggregation level, the second name the second highest aggregation level, and so on.\n\nvSize\n\nThe column must not contain negative values. This is because itâ€™s vaues will be used to map the sizes of the rectangles of the treemaps.\n\n\nWarning:\nThe treemap above was wrongly coloured. For a correctly designed treemap, the colours of the rectagles should be in different intensity showing, in our case, median unit prices.\nForÂ treemap(),Â vColorÂ is used in combination with the argumentÂ typeÂ to determines the colours of the rectangles. Without definingÂ type, like the code chunk above,Â treemap()Â assumes type = index, in our case, the hierarchy of planning areas.\n\n\n\nIn the code chunk below,Â typeÂ argument is define as value.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type = \"value\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\nThinking to learn from the conde chunk above.\n\nThe rectangles are coloured with different intensity of green, reflecting their respective median unit prices.\nThe legend reveals that the values are binned into ten bins, i.e.Â 0-5000, 5000-10000, etc. with an equal interval of 5000.\n\n\n\n\nThere are two arguments that determine the mapping to color palettes:Â mappingÂ andÂ palette. The only difference between â€œvalueâ€ and â€œmanualâ€ is the default value for mapping. The â€œvalueâ€ treemap considers palette to be a diverging color palette (say ColorBrewerâ€™s â€œRdYlBuâ€), and maps it in such a way that 0 corresponds to the middle color (typically white or yellow), -max(abs(values)) to the left-end color, and max(abs(values)), to the right-end color. The â€œmanualâ€ treemap simply maps min(values) to the left-end color, max(values) to the right-end color, and mean(range(values)) to the middle color.\n\n\n\nThe code chunk below shows a value type treemap.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"value\",\n        palette=\"RdYlBu\", \n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\nThing to learn from the code chunk above:\n\nalthough the colour palette used is RdYlBu but there are no red rectangles in the treemap above. This is because all the median unit prices are positive.\nThe reason why we see only 5000 to 45000 in the legend is because theÂ rangeÂ argument is by default c(min(values, max(values)) with some pretty rounding.\n\n\n\n\nThe â€œmanualâ€ type does not interpret the values as the â€œvalueâ€ type does. Instead, the value range is mapped linearly to the colour palette.\nThe code chunk below shows a manual type treemap.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"RdYlBu\", \n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above:\n\nThe colour scheme used is very copnfusing. This is because mapping = (min(values), mean(range(values)), max(values)). It is not wise to use diverging colour palette such asÂ RdYlBuÂ if the values are all positive or negative\n\nTo overcome this problem, a single colour palette such as Blues should be used.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"Blues\", \n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\n\n\n\ntreemap()Â supports two popular treemap layouts, namely: â€œsquarifiedâ€ and â€œpivotSizeâ€. The default is â€œpivotSizeâ€.\nThe squarified treemap algorithm (Bruls et al., 2000) produces good aspect ratios, but ignores the sorting order of the rectangles (sortID). The ordered treemap, pivot-by-size, algorithm (Bederson et al., 2002) takes the sorting order (sortID) into account while aspect ratios are still acceptable.\n\n\n\nThe code chunk below plots a squarified treemap by changing theÂ algorithmÂ argument.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"Blues\", \n        algorithm = \"squarified\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\n\n\n\nWhen â€œpivotSizeâ€ algorithm is used,Â sortIDÂ argument can be used to dertemine the order in which the rectangles are placed from top left to bottom right.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"Blues\", \n        algorithm = \"pivotSize\",\n        sortID = \"Median Transacted Price\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\n\n\n\n\ntreemapifyÂ is a R package specially developed to draw treemaps inÂ ggplot2. In this section, you will learn how to designing treemps closely resemble treemaps designing in previous section by usingÂ treemapify. Before you getting started, you should readÂ Introduction to â€œtreemapifyâ€Â itsÂ user guide.\n\n\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`),\n       layout = \"scol\",\n       start = \"bottomleft\") + \n  geom_treemap() +\n  scale_fill_gradient(low = \"light blue\", high = \"blue\")\n\n\n\n\n\n\n\n\n\n\n\nGroup by Planning Region\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`,\n           subgroup = `Planning Region`),\n       start = \"topleft\") + \n  geom_treemap()\n\n\n\n\n\n\n\n\nGroup by Planning Area\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`,\n           subgroup = `Planning Region`,\n           subgroup2 = `Planning Area`)) + \n  geom_treemap()\n\n\n\n\n\n\n\n\nAdding boundary line\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`,\n           subgroup = `Planning Region`,\n           subgroup2 = `Planning Area`)) + \n  geom_treemap() +\n  geom_treemap_subgroup2_border(colour = \"gray40\",\n                                size = 2) +\n  geom_treemap_subgroup_border(colour = \"gray20\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis slide shows you how to install a R package which is not available in cran.\n\nIf this is the first time you install a package from github, you should installÂ devtoolsÂ package by using the code below or else you can skip this step.\n\n\ndevtools::install_github(\"timelyportfolio/d3treeR\", force = TRUE)\n\nUsing GitHub PAT from the git credential store.\n\n\nDownloading GitHub repo timelyportfolio/d3treeR@HEAD\n\n\n\nâ”€â”€ R CMD build â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n* checking for file â€˜/private/var/folders/v7/kn7_1jkd60l80zw7rs_11qk00000gn/T/Rtmp770B9m/remotes2ff9700af65d/d3treeR-d3treeR-ebb833d/DESCRIPTIONâ€™ ... OK\n* preparing â€˜d3treeRâ€™:\n* checking DESCRIPTION meta-information ... OK\n* checking for LF line-endings in source and make files and shell scripts\n* checking for empty or unneeded directories\nOmitted â€˜LazyDataâ€™ from DESCRIPTION\n* building â€˜d3treeR_0.1.tar.gzâ€™\n\n\n\nNext, you will load the devtools library and install the package found in github by using the codes below.\n\n\nlibrary(devtools)\n\nLoading required package: usethis\n\ninstall_github(\"timelyportfolio/d3treeR\")\n\nUsing GitHub PAT from the git credential store.\n\n\nSkipping install of 'd3treeR' from a github remote, the SHA1 (ebb833db) has not changed since last install.\n  Use `force = TRUE` to force installation\n\n\n\nNow you are ready to launchÂ d3treeRÂ package\n\nlibrary(d3treeR)\n\n\n\n\n\nThe codes below perform two processes.\n\ntreemap()Â is used to build a treemap by using selected variables in condominium data.frame. The treemap created is save as object calledÂ tm.\n\n\nif (!requireNamespace(\"treemap\", quietly = TRUE)) {\n  install.packages(\"treemap\", dependencies = TRUE)\n}\n\n\nlibrary(treemap)\ntm &lt;- treemap(realis2018_summarised,\n        index=c(\"Planning Region\", \"Planning Area\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"value\",\n        title=\"Private Residential Property Sold, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\n\nThenÂ d3tree()Â is used to build an interactive treemap.\n\nd3tree(tm,rootname = \"Singapore\" )"
  },
  {
    "objectID": "Hands-on Exercises/Hands-on Ex 05/Hands-on Ex 5-4.html#overview",
    "href": "Hands-on Exercises/Hands-on Ex 05/Hands-on Ex 5-4.html#overview",
    "title": "Hands-on Ex 5-4",
    "section": "",
    "text": "In this hands-on exercise, you will gain hands-on experiences on designing treemap using appropriate R packages. The hands-on exercise consists of three main section. First, you will learn how to manipulate transaction data into a treemap strcuture by using selected functions provided inÂ dplyrpackage. Then, you will learn how to plot static treemap by usingÂ treemappackage. In the third section, you will learn how to design interactive treemap by usingÂ d3treeRÂ package."
  },
  {
    "objectID": "Hands-on Exercises/Hands-on Ex 05/Hands-on Ex 5-4.html#installing-and-launching-r-packages",
    "href": "Hands-on Exercises/Hands-on Ex 05/Hands-on Ex 5-4.html#installing-and-launching-r-packages",
    "title": "Hands-on Ex 5-4",
    "section": "",
    "text": "Before we get started, you are required to check ifÂ treemapÂ andÂ tidyversepacakges have been installed in you R.\n\npacman::p_load(treemap, treemapify, tidyverse)"
  },
  {
    "objectID": "Hands-on Exercises/Hands-on Ex 05/Hands-on Ex 5-4.html#data-wrangling",
    "href": "Hands-on Exercises/Hands-on Ex 05/Hands-on Ex 5-4.html#data-wrangling",
    "title": "Hands-on Ex 5-4",
    "section": "",
    "text": "In this exercise,Â REALIS2018.csvÂ data will be used. This dataset provides information of private property transaction records in 2018. The dataset is extracted from REALIS portal (https://spring.ura.gov.sg/lad/ore/login/index.cfm) of Urban Redevelopment Authority (URA).\n\n\nIn the code chunk below,Â read_csv()Â ofÂ readrÂ is used to import realis2018.csv into R and parsed it into tibble R data.frame format.\n\nrealis2018 &lt;- read_csv(\"/Users/geloliu/Gelo-608/ISSS608/Hands-on Exercises/Hands-on Ex 05/data/realis2018.csv\")\n\nRows: 23205 Columns: 20\nâ”€â”€ Column specification â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nDelimiter: \",\"\nchr (12): Project Name, Address, Type of Area, Nett Price($), Sale Date, Pro...\ndbl  (8): No. of Units, Area (sqm), Transacted Price ($), Unit Price ($ psm)...\n\nâ„¹ Use `spec()` to retrieve the full column specification for this data.\nâ„¹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nThe output tibble data.frame is calledÂ realis2018.\n\n\n\nThe data.frameÂ realis2018Â is in trasaction record form, which is highly disaggregated and not appropriate to be used to plot a treemap. In this section, we will perform the following steps to manipulate and prepare a data.frtame that is appropriate for treemap visualisation:\n\ngroup transaction records byÂ Project Name,Â Planning Region,Â Planning Area,Â Property TypeÂ andÂ Type of Sale, and\ncomputeÂ Total Unit Sold,Â Total Area,Â Median Unit PriceÂ andÂ Median Transacted PriceÂ by applying appropriate summary statistics onÂ No.Â of Units,Â Area (sqm),Â Unit Price ($ psm)Â andÂ Transacted Price ($)respectively.\n\nTwo key verbs ofÂ dplyrÂ package, namely:Â group_by()Â andÂ summarize()Â will be used to perform these steps.\ngroup_by()Â breaks down a data.frame into specified groups of rows. When you then apply the verbs above on the resulting object theyâ€™ll be automatically applied â€œby groupâ€.\nGrouping affects the verbs as follows:\n\ngroupedÂ select()Â is the same as ungroupedÂ select(), except that grouping variables are always retained.\ngroupedÂ arrange()Â is the same as ungrouped; unless you setÂ .by_group = TRUE, in which case it orders first by the grouping variables.\nmutate()Â andÂ filter()Â are most useful in conjunction with window functions (likeÂ rank(), orÂ min(x) == x). They are described in detail in vignette(â€œwindow-functionsâ€).\nsample_n()Â andÂ sample_frac()Â sample the specified number/fraction of rows in each group.\nsummarise()Â computes the summary for each group.\n\nIn our case,Â group_by()Â will used together withÂ summarise()Â to derive the summarised data.frame.\nğŸ“£ Students who are new toÂ dplyrÂ methods should consultÂ Introduction to dplyrbefore moving on to the next section.\n\n\n\nThe code chank below shows a typical two lines code approach to perform the steps.\n\nrealis2018_grouped &lt;- group_by(realis2018, `Project Name`,\n                               `Planning Region`, `Planning Area`, \n                               `Property Type`, `Type of Sale`)\nrealis2018_summarised &lt;- summarise(realis2018_grouped, \n                          `Total Unit Sold` = sum(`No. of Units`, na.rm = TRUE),\n                          `Total Area` = sum(`Area (sqm)`, na.rm = TRUE),\n                          `Median Unit Price ($ psm)` = median(`Unit Price ($ psm)`, na.rm = TRUE), \n                          `Median Transacted Price` = median(`Transacted Price ($)`, na.rm = TRUE))\n\n`summarise()` has grouped output by 'Project Name', 'Planning Region',\n'Planning Area', 'Property Type'. You can override using the `.groups`\nargument.\n\n\nğŸ“’ Note\n\nAggregation functions such asÂ sum()Â andÂ meadian()Â obey the usual rule of missing values: if thereâ€™s any missing value in the input, the output will be a missing value. The argumentÂ na.rm = TRUEÂ removes the missing values prior to computation.\n\nThe code chunk above is not very efficient because we have to give each intermediate data.frame a name, even though we donâ€™t have to care about it.\n\n\n\nThe code chunk below shows a more efficient way to tackle the same processes by using theÂ pipe, %&gt;%:\nğŸ”” Recommendation\nTo learn more about pipe, visit this excellent article:Â Pipes in R Tutorial For Beginners.\n\nrealis2018_summarised &lt;- realis2018 %&gt;% \n  group_by(`Project Name`,`Planning Region`, \n           `Planning Area`, `Property Type`, \n           `Type of Sale`) %&gt;%\n  summarise(`Total Unit Sold` = sum(`No. of Units`, na.rm = TRUE), \n            `Total Area` = sum(`Area (sqm)`, na.rm = TRUE),\n            `Median Unit Price ($ psm)` = median(`Unit Price ($ psm)`, na.rm = TRUE),\n            `Median Transacted Price` = median(`Transacted Price ($)`, na.rm = TRUE))\n\n`summarise()` has grouped output by 'Project Name', 'Planning Region',\n'Planning Area', 'Property Type'. You can override using the `.groups`\nargument."
  },
  {
    "objectID": "Hands-on Exercises/Hands-on Ex 05/Hands-on Ex 5-4.html#designing-treemap-with-treemap-package",
    "href": "Hands-on Exercises/Hands-on Ex 05/Hands-on Ex 5-4.html#designing-treemap-with-treemap-package",
    "title": "Hands-on Ex 5-4",
    "section": "",
    "text": "treemapÂ package is a R package specially designed to offer great flexibility in drawing treemaps. The core function, namely:Â treemap()Â offers at least 43 arguments. In this section, we will only explore the major arguments for designing elegent and yet truthful treemaps.\n\n\nIn this section,Â treemap()Â ofÂ TreemapÂ package is used to plot a treemap showing the distribution of median unit prices and total unit sold of resale condominium by geographic hierarchy in 2017.\nFirst, we will select records belongs to resale condominium property type fromÂ realis2018_selectedÂ data frame.\n\nrealis2018_selected &lt;- realis2018_summarised %&gt;%\n  filter(`Property Type` == \"Condominium\", `Type of Sale` == \"Resale\")\n\n\n\n\nThe code chunk below designed a treemap by using three core arguments ofÂ treemap(), namely:Â index,Â vSizeÂ andÂ vColor.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\nThings to learn from the three arguments used:\n\nindex\n\nThe index vector must consist of at least two column names or else no hierarchy treemap will be plotted.\nIf multiple column names are provided, such as the code chunk above, the first name is the highest aggregation level, the second name the second highest aggregation level, and so on.\n\nvSize\n\nThe column must not contain negative values. This is because itâ€™s vaues will be used to map the sizes of the rectangles of the treemaps.\n\n\nWarning:\nThe treemap above was wrongly coloured. For a correctly designed treemap, the colours of the rectagles should be in different intensity showing, in our case, median unit prices.\nForÂ treemap(),Â vColorÂ is used in combination with the argumentÂ typeÂ to determines the colours of the rectangles. Without definingÂ type, like the code chunk above,Â treemap()Â assumes type = index, in our case, the hierarchy of planning areas.\n\n\n\nIn the code chunk below,Â typeÂ argument is define as value.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type = \"value\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\nThinking to learn from the conde chunk above.\n\nThe rectangles are coloured with different intensity of green, reflecting their respective median unit prices.\nThe legend reveals that the values are binned into ten bins, i.e.Â 0-5000, 5000-10000, etc. with an equal interval of 5000.\n\n\n\n\nThere are two arguments that determine the mapping to color palettes:Â mappingÂ andÂ palette. The only difference between â€œvalueâ€ and â€œmanualâ€ is the default value for mapping. The â€œvalueâ€ treemap considers palette to be a diverging color palette (say ColorBrewerâ€™s â€œRdYlBuâ€), and maps it in such a way that 0 corresponds to the middle color (typically white or yellow), -max(abs(values)) to the left-end color, and max(abs(values)), to the right-end color. The â€œmanualâ€ treemap simply maps min(values) to the left-end color, max(values) to the right-end color, and mean(range(values)) to the middle color.\n\n\n\nThe code chunk below shows a value type treemap.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"value\",\n        palette=\"RdYlBu\", \n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\nThing to learn from the code chunk above:\n\nalthough the colour palette used is RdYlBu but there are no red rectangles in the treemap above. This is because all the median unit prices are positive.\nThe reason why we see only 5000 to 45000 in the legend is because theÂ rangeÂ argument is by default c(min(values, max(values)) with some pretty rounding.\n\n\n\n\nThe â€œmanualâ€ type does not interpret the values as the â€œvalueâ€ type does. Instead, the value range is mapped linearly to the colour palette.\nThe code chunk below shows a manual type treemap.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"RdYlBu\", \n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above:\n\nThe colour scheme used is very copnfusing. This is because mapping = (min(values), mean(range(values)), max(values)). It is not wise to use diverging colour palette such asÂ RdYlBuÂ if the values are all positive or negative\n\nTo overcome this problem, a single colour palette such as Blues should be used.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"Blues\", \n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\n\n\n\ntreemap()Â supports two popular treemap layouts, namely: â€œsquarifiedâ€ and â€œpivotSizeâ€. The default is â€œpivotSizeâ€.\nThe squarified treemap algorithm (Bruls et al., 2000) produces good aspect ratios, but ignores the sorting order of the rectangles (sortID). The ordered treemap, pivot-by-size, algorithm (Bederson et al., 2002) takes the sorting order (sortID) into account while aspect ratios are still acceptable.\n\n\n\nThe code chunk below plots a squarified treemap by changing theÂ algorithmÂ argument.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"Blues\", \n        algorithm = \"squarified\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\n\n\n\nWhen â€œpivotSizeâ€ algorithm is used,Â sortIDÂ argument can be used to dertemine the order in which the rectangles are placed from top left to bottom right.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"Blues\", \n        algorithm = \"pivotSize\",\n        sortID = \"Median Transacted Price\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )"
  },
  {
    "objectID": "Hands-on Exercises/Hands-on Ex 05/Hands-on Ex 5-4.html#designing-treemap-using-treemapifypackage",
    "href": "Hands-on Exercises/Hands-on Ex 05/Hands-on Ex 5-4.html#designing-treemap-using-treemapifypackage",
    "title": "Hands-on Ex 5-4",
    "section": "",
    "text": "treemapifyÂ is a R package specially developed to draw treemaps inÂ ggplot2. In this section, you will learn how to designing treemps closely resemble treemaps designing in previous section by usingÂ treemapify. Before you getting started, you should readÂ Introduction to â€œtreemapifyâ€Â itsÂ user guide.\n\n\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`),\n       layout = \"scol\",\n       start = \"bottomleft\") + \n  geom_treemap() +\n  scale_fill_gradient(low = \"light blue\", high = \"blue\")\n\n\n\n\n\n\n\n\n\n\n\nGroup by Planning Region\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`,\n           subgroup = `Planning Region`),\n       start = \"topleft\") + \n  geom_treemap()\n\n\n\n\n\n\n\n\nGroup by Planning Area\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`,\n           subgroup = `Planning Region`,\n           subgroup2 = `Planning Area`)) + \n  geom_treemap()\n\n\n\n\n\n\n\n\nAdding boundary line\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`,\n           subgroup = `Planning Region`,\n           subgroup2 = `Planning Area`)) + \n  geom_treemap() +\n  geom_treemap_subgroup2_border(colour = \"gray40\",\n                                size = 2) +\n  geom_treemap_subgroup_border(colour = \"gray20\")"
  },
  {
    "objectID": "Hands-on Exercises/Hands-on Ex 05/Hands-on Ex 5-4.html#designing-interactive-treemap-using-d3treer",
    "href": "Hands-on Exercises/Hands-on Ex 05/Hands-on Ex 5-4.html#designing-interactive-treemap-using-d3treer",
    "title": "Hands-on Ex 5-4",
    "section": "",
    "text": "This slide shows you how to install a R package which is not available in cran.\n\nIf this is the first time you install a package from github, you should installÂ devtoolsÂ package by using the code below or else you can skip this step.\n\n\ndevtools::install_github(\"timelyportfolio/d3treeR\", force = TRUE)\n\nUsing GitHub PAT from the git credential store.\n\n\nDownloading GitHub repo timelyportfolio/d3treeR@HEAD\n\n\n\nâ”€â”€ R CMD build â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n* checking for file â€˜/private/var/folders/v7/kn7_1jkd60l80zw7rs_11qk00000gn/T/Rtmp770B9m/remotes2ff9700af65d/d3treeR-d3treeR-ebb833d/DESCRIPTIONâ€™ ... OK\n* preparing â€˜d3treeRâ€™:\n* checking DESCRIPTION meta-information ... OK\n* checking for LF line-endings in source and make files and shell scripts\n* checking for empty or unneeded directories\nOmitted â€˜LazyDataâ€™ from DESCRIPTION\n* building â€˜d3treeR_0.1.tar.gzâ€™\n\n\n\nNext, you will load the devtools library and install the package found in github by using the codes below.\n\n\nlibrary(devtools)\n\nLoading required package: usethis\n\ninstall_github(\"timelyportfolio/d3treeR\")\n\nUsing GitHub PAT from the git credential store.\n\n\nSkipping install of 'd3treeR' from a github remote, the SHA1 (ebb833db) has not changed since last install.\n  Use `force = TRUE` to force installation\n\n\n\nNow you are ready to launchÂ d3treeRÂ package\n\nlibrary(d3treeR)\n\n\n\n\n\nThe codes below perform two processes.\n\ntreemap()Â is used to build a treemap by using selected variables in condominium data.frame. The treemap created is save as object calledÂ tm.\n\n\nif (!requireNamespace(\"treemap\", quietly = TRUE)) {\n  install.packages(\"treemap\", dependencies = TRUE)\n}\n\n\nlibrary(treemap)\ntm &lt;- treemap(realis2018_summarised,\n        index=c(\"Planning Region\", \"Planning Area\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"value\",\n        title=\"Private Residential Property Sold, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\n\nThenÂ d3tree()Â is used to build an interactive treemap.\n\nd3tree(tm,rootname = \"Singapore\" )"
  }
]